# file: .github/workflows/release-javascript.yml
# version: 1.0.0
# guid: e5f6a7b8-c9d0-1e2f-3a4b-5c6d7e8f9a0b

name: JavaScript Release

on:
  workflow_call:
    inputs:
      release_type:
        description: "Release type"
        required: false
        default: "auto"
        type: string
      prerelease:
        description: "Is this a prerelease?"
        required: false
        default: false
        type: boolean
      draft:
        description: "Create as draft?"
        required: false
        default: false
        type: boolean
    outputs:
      version:
        description: "The released version"
        value: ${{ jobs.release.outputs.version }}
      tag:
        description: "The release tag"
        value: ${{ jobs.release.outputs.tag }}

permissions:
  contents: write
  packages: write
  attestations: write
  id-token: write

env:
  NODE_VERSION: "22"

jobs:
  determine-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      changelog: ${{ steps.version.outputs.changelog }}
      should-release: ${{ steps.version.outputs.should-release }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Create semantic-release config for JavaScript
        run: |
          cat > .releaserc.json << EOF
          {
            "branches": ["main"],
            "plugins": [
              [
                "@semantic-release/commit-analyzer",
                {
                  "preset": "conventionalcommits",
                  "releaseRules": [
                    {"type": "feat", "release": "minor"},
                    {"type": "fix", "release": "patch"},
                    {"type": "perf", "release": "patch"},
                    {"type": "revert", "release": "patch"},
                    {"type": "docs", "release": false},
                    {"type": "style", "release": false},
                    {"type": "chore", "release": false},
                    {"type": "refactor", "release": "patch"},
                    {"type": "test", "release": false},
                    {"type": "build", "release": false},
                    {"type": "ci", "release": false},
                    {"breaking": true, "release": "major"}
                  ]
                }
              ],
              [
                "@semantic-release/release-notes-generator",
                {
                  "preset": "conventionalcommits"
                }
              ],
              "@semantic-release/npm",
              [
                "@semantic-release/changelog",
                {
                  "changelogFile": "CHANGELOG.md"
                }
              ],
              [
                "@semantic-release/git",
                {
                  "assets": ["package.json", "package-lock.json", "CHANGELOG.md"],
                  "message": "chore(release): \${nextRelease.version} [skip ci]\n\n\${nextRelease.notes}"
                }
              ],
              "@semantic-release/github"
            ]
          }
          EOF

      - name: Determine next version
        id: version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MANUAL_RELEASE_TYPE: ${{ inputs.release_type }}
        run: |
          if [[ "$MANUAL_RELEASE_TYPE" != "auto" && "$MANUAL_RELEASE_TYPE" != "" ]]; then
            echo "Manual release type specified: $MANUAL_RELEASE_TYPE"
            CURRENT_VERSION=$(node -p "require('./package.json').version")
            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            MAJOR=${VERSION_PARTS[0]}
            MINOR=${VERSION_PARTS[1]}
            PATCH=${VERSION_PARTS[2]}

            case "$MANUAL_RELEASE_TYPE" in
              "major")
                NEW_VERSION="$((MAJOR + 1)).0.0"
                ;;
              "minor")
                NEW_VERSION="$MAJOR.$((MINOR + 1)).0"
                ;;
              "patch")
                NEW_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
                ;;
            esac

            echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
            echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
            echo "should-release=true" >> $GITHUB_OUTPUT
            echo "changelog=Manual $MANUAL_RELEASE_TYPE release" >> $GITHUB_OUTPUT
          else
            # Run semantic-release in dry-run mode to determine version
            npx semantic-release --dry-run > release_output.log 2>&1 || true

            if grep -q "The next release version is" release_output.log; then
              NEW_VERSION=$(grep "The next release version is" release_output.log | sed 's/.*The next release version is \([0-9.]*\).*/\1/')
              echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
              echo "tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
              echo "should-release=true" >> $GITHUB_OUTPUT

              # Extract changelog
              CHANGELOG=$(npx semantic-release --dry-run 2>&1 | grep -A 100 "Release note for version" | tail -n +2 | head -n -1 || echo "Automated release")
              echo "changelog<<EOF" >> $GITHUB_OUTPUT
              echo "$CHANGELOG" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
            else
              echo "No release needed based on conventional commits"
              echo "should-release=false" >> $GITHUB_OUTPUT
            fi
          fi

  build:
    name: Build JavaScript Package
    runs-on: ubuntu-latest
    needs: determine-version
    if: needs.determine-version.outputs.should-release == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Update package version
        run: |
          npm version "${{ needs.determine-version.outputs.version }}" --no-git-tag-version

      - name: Run linting
        run: |
          if npm run lint --if-present; then
            echo "Linting passed"
          else
            echo "No lint script found or linting failed"
          fi

      - name: Run tests
        run: |
          if npm test --if-present; then
            echo "Tests passed"
          else
            echo "No test script found or tests failed"
          fi

      - name: Build package
        run: |
          if npm run build --if-present; then
            echo "Build completed"
          else
            echo "No build script found"
          fi

      - name: Create package tarball
        run: npm pack

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: javascript-package
          path: "*.tgz"

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [determine-version, build]
    if: needs.determine-version.outputs.should-release == 'true'
    outputs:
      version: ${{ needs.determine-version.outputs.version }}
      tag: ${{ needs.determine-version.outputs.tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts
          merge-multiple: true

      - name: List artifacts
        run: ls -la ./artifacts/

      - name: Create semantic-release config for JavaScript
        run: |
          cat > .releaserc.json << EOF
          {
            "branches": ["main"],
            "plugins": [
              [
                "@semantic-release/commit-analyzer",
                {
                  "preset": "conventionalcommits",
                  "releaseRules": [
                    {"type": "feat", "release": "minor"},
                    {"type": "fix", "release": "patch"},
                    {"type": "perf", "release": "patch"},
                    {"type": "revert", "release": "patch"},
                    {"type": "docs", "release": false},
                    {"type": "style", "release": false},
                    {"type": "chore", "release": false},
                    {"type": "refactor", "release": "patch"},
                    {"type": "test", "release": false},
                    {"type": "build", "release": false},
                    {"type": "ci", "release": false},
                    {"breaking": true, "release": "major"}
                  ]
                }
              ],
              [
                "@semantic-release/release-notes-generator",
                {
                  "preset": "conventionalcommits"
                }
              ],
              "@semantic-release/npm",
              [
                "@semantic-release/changelog",
                {
                  "changelogFile": "CHANGELOG.md"
                }
              ],
              [
                "@semantic-release/git",
                {
                  "assets": ["package.json", "package-lock.json", "CHANGELOG.md"],
                  "message": "chore(release): \${nextRelease.version} [skip ci]\n\n\${nextRelease.notes}"
                }
              ],
              [
                "@semantic-release/github",
                {
                  "assets": [
                    "./artifacts/*.tgz"
                  ]
                }
              ]
            ]
          }
          EOF

      - name: Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          if [[ "${{ inputs.release_type }}" != "auto" && "${{ inputs.release_type }}" != "" ]]; then
            # Manual release - create GitHub release directly
            npm version "${{ needs.determine-version.outputs.version }}" --no-git-tag-version
            gh release create "${{ needs.determine-version.outputs.tag }}" \
              --title "Release ${{ needs.determine-version.outputs.version }}" \
              --notes "${{ needs.determine-version.outputs.changelog }}" \
              ${{ inputs.prerelease && '--prerelease' || '' }} \
              ${{ inputs.draft && '--draft' || '' }} \
              ./artifacts/*
          else
            # Use semantic-release for automated releases
            npx semantic-release
          fi
